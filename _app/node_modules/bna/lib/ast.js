// Generated by CoffeeScript 1.8.0
(function() {
  var ast, _;

  _ = require("under_score");

  module.exports = ast = {

    /*
      filters: an array of filter functions
      example:
      ast.traverse esprima.parse(src, opt), (node)->
     */
    traverse: function(node, filters, cb) {
      var filter;
      if (_(filters).isFunction()) {
        cb = filters;
        filters = [];
      }
      if (filters.length === 0) {
        filter = function(node) {
          return true;
        };
      } else {
        filter = function(node) {
          var f;
          return ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = filters.length; _i < _len; _i++) {
              f = filters[_i];
              if (f(node)) {
                _results.push(f);
              }
            }
            return _results;
          })()).length > 0;
        };
      }
      return ast._traverse(node, filter, cb);
    },
    _traverse: function(node, filter, cb) {
      var key, n, _i, _len, _results, _results1;
      if (Array.isArray(node)) {
        _results = [];
        for (_i = 0, _len = node.length; _i < _len; _i++) {
          n = node[_i];
          _results.push(ast._traverse(n, filter, cb));
        }
        return _results;
      } else if (node && typeof node === 'object') {
        if (filter(node)) {
          cb(node);
        }
        _results1 = [];
        for (key in node) {
          n = node[key];
          if (n) {
            _results1.push(ast._traverse(n, filter, cb));
          }
        }
        return _results1;
      } else {
        if (filter(node)) {
          return cb(node);
        }
      }
    },
    isFunc: function(node, name) {
      return node && node.callee && node.type === 'CallExpression' && node.callee.type === 'Identifier' && ((!name) || node.callee.name === name);
    },
    isRequire: function(node) {
      return ast.isFunc(node, 'require');
    }
  };

}).call(this);

//# sourceMappingURL=ast.js.map
