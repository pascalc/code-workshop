// Generated by CoffeeScript 1.8.0

/*
  The "code fusion", generates one working js from commonJs require modules.

  1. supports circular dependency: as long as the source works in nodejs, so should the generated code
  2. original source code is not modified.  Instead code is injected to simulate commonJS require.
  3. recognizes nodejs native components "*.node"
  4. recursive fuse:  fused code can be fused, minified (or not), required and then fused again.

  To learn more, look at generated code.
 */

(function() {
  var fs, fuse, path, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require("path");

  fs = require("fs");

  _ = require("under_score");

  module.exports = fuse = {
    generate: function(_arg) {
      var asLib, baseDir, binaryUnits, code, coreUnits, fileUnits, i, includePackage, key, lmapcode, moduleName, oldunit, packages, pkginfo, r, sCoreRequires, smMatch, smRegex, src, unit, units, verbose, _i, _j, _k, _len, _len1, _len2;
      baseDir = _arg.baseDir, moduleName = _arg.moduleName, units = _arg.units, asLib = _arg.asLib, includePackage = _arg.includePackage, verbose = _arg.verbose;
      coreUnits = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = units.length; _i < _len; _i++) {
          unit = units[_i];
          if (unit.isCore) {
            _results.push(unit);
          }
        }
        return _results;
      })();
      binaryUnits = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = units.length; _i < _len; _i++) {
          unit = units[_i];
          if (unit.isBinary) {
            _results.push(unit);
          }
        }
        return _results;
      })();
      fileUnits = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = units.length; _i < _len; _i++) {
          unit = units[_i];
          if (!unit.isCore && !unit.isBinary) {
            _results.push(unit);
          }
        }
        return _results;
      })();
      fuse._makeKeys(fileUnits.concat(binaryUnits));
      for (_i = 0, _len = coreUnits.length; _i < _len; _i++) {
        unit = coreUnits[_i];
        unit.key = unit.fpath;
      }
      sCoreRequires = ((function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = coreUnits.length; _j < _len1; _j++) {
          unit = coreUnits[_j];
          _results.push("__m['" + unit.key + "'] = {\n  sts  : 1,\n  mod  : {exports: __m.__sr('" + unit.key + "')}\n};");
        }
        return _results;
      })()).join('\n');
      (function(_this) {
        return (function() {
          var binName, mem, _j, _len1, _results;
          mem = {};
          _results = [];
          for (_j = 0, _len1 = binaryUnits.length; _j < _len1; _j++) {
            unit = binaryUnits[_j];
            binName = path.basename(unit.fpath);
            while (__indexOf.call(mem, binName) >= 0) {
              binName = '_' + binName;
            }
            unit.binName = binName;
            _results.push(sCoreRequires += "__m['" + unit.key + "'] = {\n  sts  : null,\n  mod  : {exports: {}},\n  load : function() { return (__m['" + unit.key + "'].mod.exports = __m.__sr('./" + binName + "')); }\n};");
          }
          return _results;
        });
      })(this)();
      code = "(function(run, root) {\n  var ret = run.bind(root)();\n  if ('" + moduleName + "') root['" + moduleName + "'] = ret;\n  if (\"object\" == typeof exports && \"undefined\" != typeof module)\n    module.exports = ret;\n}(function() {\nvar __m = {};\nif (typeof require === 'undefined') __m.__sr = function() {};\nelse __m.__sr = require;\n__m.__r = function(key) {\n  var m = __m[key];\n  if (m.sts === null) m.load.call();\n  return m.mod.exports;\n};\n" + sCoreRequires;
      smRegex = /\/\/# sourceMappingURL=([_\w\-\.\~]+)/;
      for (i = _j = 0, _len1 = fileUnits.length; _j < _len1; i = ++_j) {
        unit = fileUnits[i];
        i = i + 1;
        smMatch = smRegex.exec(unit.src);
        if (smMatch) {
          src = unit.src.replace("//# sourceMappingURL=", "// sourceMappingURL=");
          unit.sm = {
            url: smMatch[1]
          };
        } else {
          src = unit.src;
        }
        if (path.extname(unit.fpath) === ".json") {
          code += "__m['" + unit.key + "'] = {\n  sts: 1,\n  mod: { exports:";
          if (unit.sm) {
            unit.sm.line = fuse._lc(code);
          }
          code += src;
          code += "}};\n";
        } else {
          lmapcode = ((function() {
            var _k, _len2, _ref, _results;
            _ref = unit.requires;
            _results = [];
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
              r = _ref[_k];
              _results.push("        '" + r.node["arguments"][0].value + "': '" + r.unit.key + "'");
            }
            return _results;
          })()).join(",\n");
          pkginfo = unit["package"] ? "" + unit["package"].name + "@" + (unit["package"].version || '') : "";
          pkginfo += "(" + (path.basename(unit.fpath)) + ")";
          code += "__m['" + unit.key + "'] = {\n  sts: null,\n  mod: { " + (unit["package"] && includePackage ? "package: " + (JSON.stringify(unit["package"])) + "," : "") + "\n    exports: {} },\n  load: (function() {\n    var module = __m['" + unit.key + "'].mod;\n    var exports = module.exports;\n    var require = function(name) {\n      var namemap = {\n" + lmapcode + "\n      }\n      var k = namemap[name];\n      return k ? __m.__r(k) : __m.__sr(name);\n    }\n    require.resolve = __m.__sr.resolve;\n    __m['" + unit.key + "'].sts = 0;\n//******** begin file " + pkginfo + " ************\n";
          if (unit.sm) {
            unit.sm.line = fuse._lc(code);
          }
          code += src;
          code += "//******** end file " + pkginfo + "************\n    __m['" + unit.key + "'].sts = 1;\n  }).bind(this)\n};\n";
        }
      }
      if (asLib) {
        code += "return {\n";
        packages = {};
        for (_k = 0, _len2 = fileUnits.length; _k < _len2; _k++) {
          unit = fileUnits[_k];
          if (unit["package"]) {
            if (unit["package"].name in packages) {
              oldunit = packages[unit["package"].name];
              if (oldunit["package"].version !== unit["package"].version) {
                packages["" + oldunit["package"].name + "@" + oldunit["package"].version] = oldunit;
                packages["" + unit["package"].name + "@" + unit["package"].version] = unit;
              }
            } else {
              packages[unit["package"].name] = unit;
            }
          }
        }
        for (key in packages) {
          unit = packages[key];
          code += "'" + key + "':  __m.__r('" + unit.key + "'),\n";
        }
        code += "};\n";
      } else {
        code += "\nreturn __m.__r('" + (_(fileUnits).last().key) + "');\n";
      }
      code += "\n},this));";
      return [code, binaryUnits, fuse._generateSourceMap(baseDir, code, fileUnits, verbose)];
    },
    _generateSourceMap: function(baseDir, code, units, verbose) {
      var e, i, s, sec, sections, sm, sp, unit, unitDir, url, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
      sections = [];
      for (_i = 0, _len = units.length; _i < _len; _i++) {
        unit = units[_i];
        if (!unit.sm) {
          continue;
        }
        unitDir = path.dirname(unit.fpath);
        url = path.resolve(unitDir, unit.sm.url);
        try {
          sm = JSON.parse(fs.readFileSync(url));
        } catch (_error) {
          e = _error;
          if (verbose) {
            console.log("Skipped invalid source map file " + (path.relative(baseDir, url)));
          }
          continue;
        }
        if (sm.sections) {
          _ref = sm.sections || [];
          for (i = _j = 0, _len1 = _ref.length; _j < _len1; i = ++_j) {
            sec = _ref[i];
            sec.offset.line += unit.sm.line;
            _ref1 = sec.map.sources;
            for (i = _k = 0, _len2 = _ref1.length; _k < _len2; i = ++_k) {
              s = _ref1[i];
              sp = path.resolve(unitDir, (sm.sourceRoot || '') + s);
              sec.map.sources[i] = path.relative(baseDir, sp);
            }
          }
          sections.push.apply(sections, sm.sections);
        } else {
          _ref2 = sm.sources;
          for (i = _l = 0, _len3 = _ref2.length; _l < _len3; i = ++_l) {
            s = _ref2[i];
            sp = path.resolve(unitDir, (sm.sourceRoot || '') + s);
            sm.sources[i] = path.relative(baseDir, sp);
          }
          sections.push({
            offset: {
              line: unit.sm.line,
              column: 0
            },
            map: sm
          });
        }
      }
      if (sections.length === 0) {
        return null;
      } else {
        return {
          version: 3,
          file: '',
          sections: sections
        };
      }
    },
    _lc: function(str) {
      var c, i, _i, _ref;
      c = 0;
      for (i = _i = 0, _ref = str.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (str[i] === '\n') {
          c++;
        }
      }
      return c;
    },
    _makeKeys: function(units) {
      var c, i, unit, _i, _len, _results;
      c = function(i) {
        var x;
        return ((function() {
          var _i, _ref, _results;
          _results = [];
          for (x = _i = 0, _ref = Math.floor(i / 26); 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
            _results.push(i % 26);
          }
          return _results;
        })()).reduce(function(r, j) {
          return r + String.fromCharCode('a'.charCodeAt(0) + j);
        }, '');
      };
      _results = [];
      for (i = _i = 0, _len = units.length; _i < _len; i = ++_i) {
        unit = units[i];
        _results.push(unit.key = c(i));
      }
      return _results;
    },
    _makeSensibleKeys: function(units) {
      var commonPrefix, pfix, unit, _i, _len, _results;
      commonPrefix = function(s1, s2) {
        var i, _i, _ref;
        for (i = _i = 0, _ref = Math.min(s1.length, s2.length); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (s1[i] !== s2[i]) {
            break;
          }
        }
        if (s1.length < s2.length) {
          return s1.slice(0, i);
        } else {
          return s2.slice(0, i);
        }
      };
      pfix = units.slice(1).reduce((function(pfix, unit) {
        return commonPrefix(pfix, unit.fpath);
      }), units[0].fpath);
      pfix = pfix.replace(/[^\/\\]*$/, '');
      _results = [];
      for (_i = 0, _len = units.length; _i < _len; _i++) {
        unit = units[_i];
        _results.push(unit.key = unit.fpath.slice(pfix.length).replace(/\\/g, '/'));
      }
      return _results;
    }
  };

}).call(this);

//# sourceMappingURL=fuse.js.map
