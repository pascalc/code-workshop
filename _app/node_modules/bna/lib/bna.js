// Generated by CoffeeScript 1.8.0
(function() {
  var ast, async, bna, esprima, fs, path, resolver, wrench, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require("fs");

  resolver = require("resolve");

  async = require("async");

  path = require("path");

  _ = require("under_score");

  esprima = require('esprima');

  ast = require("./ast");

  wrench = require("wrench");

  require("colors");

  module.exports = bna = {
    quiet: false,
    warn: function(msg) {
      if (!bna.quiet) {
        return console.log(msg.gray);
      }
    },
    _cache: {},

    /*
     * given path to js file (as returned by require.resolve), identify the node module that contains it, think of it
     * as reverse of require.resolve
     * returns
     *
     * @param file  : path to js file to identify
     * @returns  {
     *    "require": "mylib"
     *     "path"   : "node_modules/mylib/file.js",
     *     "mpath"  : "node_modules/mylib",
     *     "package" : { package.json object if exists }
     *   }
     *   - "mpath" may point to a file in case of node_modules/mylib.js
     */
    identify: function(file) {
      var packageJsonFile, ret;
      ret = {
        "path": file,
        isSysModule: function() {
          return this.path === this.require;
        }
      };
      ret.mpath = /\/|\\/.test(file) ? bna.findModulePath(file) : file;
      if (ret.mpath === file) {
        ret.require = path.basename(ret.mpath).replace(/\.(js|node)$/i, '');
      } else {
        ret.require = path.basename(ret.mpath);
        packageJsonFile = path.join(ret.mpath, "package.json");
        if (fs.existsSync(packageJsonFile)) {
          ret["package"] = JSON.parse(fs.readFileSync(packageJsonFile));
        }
      }
      return ret;
    },
    findModulePath: function(fullpath) {
      var packageJsonFile, parentpath;
      if (!fullpath || fullpath === "/") {
        return void 0;
      }
      if (fs.existsSync(path.join(fullpath, "package.json"))) {
        return fullpath;
      }
      parentpath = path.dirname(fullpath);
      packageJsonFile = path.join(parentpath, "package.json");
      if (fs.existsSync(packageJsonFile)) {
        return parentpath;
      } else if (path.basename(parentpath) === "node_modules") {
        return fullpath;
      } else {
        return bna.findModulePath(parentpath);
      }
    },
    mainFile: function(mpath) {
      fpath;
      var fpath, pkg;
      if (fs.existsSync(fpath = path.join(mpath, "package.json"))) {
        pkg = JSON.parse(fs.readFileSync(fpath));
        if ("main" in pkg) {
          return path.resolve(mpath, pkg.main);
        }
      } else if (fs.existsSync(fpath = path.join(mpath, "index.js"))) {
        return fpath;
      } else if (fs.existsSync(fpath = path.join(mpath, "index.node"))) {
        return fpath;
      }
      return null;
    },

    /*
     * async resolve all dependencies of file,
     * because nodejs supports circular require, returned data may contain circular reference, so when you recursively
     * walk the tree, make sure you handle the circular reference, see "_collapsePackages" for example.
     *
     * @param file          : path to the js file
     * @param level         : recursively resolve up to this many levels, optional, default infinite
     * @param cb(err, detail) : where obj is what's returned by identify, with addition of 'deps' member
     *                        detail.deps   :  what this file depends on, as an array of more 'identify' details
     */
    resolve: function(file, level, cb) {
      var detail;
      if (_(level).isFunction()) {
        cb = level;
        level = -1;
      }
      detail = bna.identify(file);
      bna._cache[file] = detail;
      if (level === 0 || detail.isSysModule()) {
        cb(null, detail);
        return;
      }
      return async.waterfall([
        function(cb) {
          var allrequires, expr, expressions, loc, name, pl, requires, _i, _len, _ref;
          allrequires = bna.findRequire(file);
          if (allrequires.expressions.length > 0) {
            expressions = bna.findRequire(file, {
              loc: true
            }).expressions;
            pl = function(p) {
              return path.relative(process.cwd(), p);
            };
            for (_i = 0, _len = expressions.length; _i < _len; _i++) {
              _ref = expressions[_i], expr = _ref[0], loc = _ref[1];
              bna.warn("Warning: dynamic require detected at " + (pl(loc.file)) + ":" + loc.start.line);
            }
          }
          requires = (function() {
            var _j, _len1, _ref1, _ref2, _results;
            _ref1 = allrequires.strings;
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              _ref2 = _ref1[_j], name = _ref2[0], loc = _ref2[1];
              _results.push(name);
            }
            return _results;
          })();
          return async.map(requires, function(require_item, cb) {
            return resolver(require_item, {
              extensions: [".js", ".node", ".json"],
              basedir: path.dirname(path.resolve(file))
            }, function(err, resolved) {
              if (err) {
                return cb(null, null);
              } else {
                return cb(null, resolved);
              }
            });
          }, function(err, resolved_items) {
            resolved_items = _.compact(resolved_items);
            return cb(err, resolved_items);
          });
        }, function(depend_files, cb) {
          return async.map(depend_files, function(resolved_file, cb) {
            if (resolved_file in bna._cache) {
              return cb(null, bna._cache[resolved_file]);
            } else {
              return bna.resolve(resolved_file, level - 1, cb);
            }
          }, function(err, details) {
            detail.deps = details;
            return cb(err, detail);
          });
        }
      ], cb);
    },

    /*
        Internal, collapse dependent files belong to same package
        parameter is not modified
     */
    _collapsePackages: function(paramDetail) {
      var doCollapse, memory;
      memory = {};
      doCollapse = function(paramDetail) {
        var deps, detail;
        memory[paramDetail.mpath] = true;
        detail = _({}).extend(paramDetail);
        if (!detail.deps) {
          return detail;
        }
        deps = _(detail.deps).reduce(function(memo, dep) {
          if (detail.mpath === dep.mpath) {
            if (dep.deps !== void 0) {
              _(memo).append(dep.deps);
            }
          } else {
            memo.push(dep);
          }
          return memo;
        }, []);
        detail.deps = _(deps).chain().map(function(dep) {
          if (memory[dep.mpath]) {
            return dep;
          } else {
            return doCollapse(dep);
          }
        }).unique(function(dep) {
          return dep.mpath;
        }).value();
        return detail;
      };
      return doCollapse(paramDetail);
    },

    /*
     * figures out module dependencies for you,
     *  how does it work?  by finding the main file for a package, then walk through ast of the file, find all requires
     *  to determine the external&local packages in its dependencies.
     *   * external : a required external and non-system node module
     *   * local    : the module exists locally (can be resolved via require.resolve)
     *
     * @param fpath          : path of main module file, should be what's returned by require.resolve('module')
     * @param cb(err, dependencies), dependencies is what npm expects in package.json
     */
    npmDependencies: function(fpath, cb) {
      return bna.resolve(require.resolve(fpath), function(err, detail) {
        var dependencies;
        if (err) {
          return cb(err);
        }
        detail = bna._collapsePackages(detail);
        dependencies = null;
        if (!err) {
          dependencies = _(detail.deps).reduce(function(memo, depDetail) {
            if (depDetail["package"]) {
              memo[depDetail.require] = depDetail["package"].version;
            } else if (!depDetail.isSysModule()) {
              memo[depDetail.require] = null;
            }
            return memo;
          }, {});
        }
        return cb(err, dependencies);
      });
    },

    /*
     *  Give a module, find all its dependencies that are NOT located in its local node_module path, useful
     *  for building the final app
     *
     * @param file     : path of main module file, should be what's returned by require.resolve('module')
     * @param cb (err, dependencies), where dependencies is an array of following object:
     *          {
     *              "require"   : require_name,
     *              "mpath"     : path to module,
     *              "version"   : version of module in package.json
     *          }
     *          * the first element in dependencies point to the module containing parameter file
     */
    externDependModules: function(file, cb) {
      return bna.resolve(file, function(err, detail) {
        var isPathContained, memory, ret, walk;
        if (err) {
          return cb(err);
        }
        detail = bna._collapsePackages(detail);
        ret = [detail];
        isPathContained = function(path) {
          var e, i, _i, _len;
          for (i = _i = 0, _len = ret.length; _i < _len; i = ++_i) {
            e = ret[i];
            if (path.indexOf(e.mpath) === 0) {
              return true;
            }
          }
          return false;
        };
        memory = {};
        walk = function(detail) {
          memory[detail.mpath] = true;
          if (!detail.isSysModule() && !isPathContained(detail.mpath)) {
            ret.push(detail);
          }
          if (detail.deps) {
            return detail.deps.forEach(function(dep) {
              if (!memory[dep.mpath]) {
                return walk(dep);
              }
            });
          }
        };
        walk(detail);
        ret = _(ret).chain().map(function(detail) {
          return {
            'require': detail.require,
            'mpath': detail.mpath,
            'version': detail["package"] ? detail["package"].version : null
          };
        }).unique(function(detail) {
          return detail.mpath;
        }).value();
        return cb(err, ret);
      });
    },
    dir: {
      _scanDir: function(dir, iteratorCb, doneCb) {
        return async.waterfall([
          function(cb) {
            var files, fnpm;
            files = [];
            fnpm = require("fstream-npm");
            return fnpm({
              path: dir
            }).on("child", function(c) {
              return files.push(c._path);
            }).on('close', function() {
              return cb(null, files);
            });
          }, function(files, cb) {
            return async.each(files, function(file, cb) {
              return fs.stat(file, function(err, stat) {
                if (stat.isDirectory() && path.basename(file) !== 'node_modules') {
                  return iteratorCb(file, true, cb);
                } else if (path.extname(file) === ".js") {
                  return iteratorCb(file, false, cb);
                } else {
                  return cb();
                }
              });
            }, cb);
          }
        ], doneCb);
      },
      npmDependencies: function(dir, cb) {
        var alldeps;
        alldeps = {};
        return bna.dir._scanDir(dir, function(file, isDir, cb) {
          var f;
          f = isDir ? bna.dir.npmDependencies : bna.npmDependencies;
          return f(file, function(err, deps) {
            _(alldeps).extend(deps);
            return cb(err);
          });
        }, function(err) {
          var detail;
          detail = bna.identify(dir);
          delete alldeps[detail.require];
          return cb(err, alldeps);
        });
      },
      externDependModules: function(dir, cb) {
        var alldeps;
        alldeps = [];
        return bna.dir._scanDir(dir, function(file, isDir, cb) {
          var f;
          f = isDir ? bna.dir.externDependModules : bna.externDependModules;
          return f(file, function(err, deps) {
            _(alldeps).append(deps);
            return cb(err);
          });
        }, function(err) {
          var deps;
          deps = _(alldeps).chain().unique(function(d) {
            return d.mpath;
          }).filter(function(d) {
            return d.mpath.indexOf(dir) !== 0;
          }).value();
          deps = _([alldeps[0]]).append(deps);
          return cb(err, deps);
        });
      }
    },

    /*
     * Make extern dependencies local by copying them to local node_modules folder
     * @param mpath     path to a dir or file (the file must be main entry point of module, i.e. returned by require.resolve
     * @param progressCb (msg),  copy in progress callback, if you want to print status
     * @param doneCb(err) completion callback
     *
     */
    copyExternDependModules: function(mpath, progressCb, doneCb) {
      return fs.stat(mpath, function(err, stat) {
        var f;
        if (err) {
          return cb(err);
        }
        f = stat.isDirectory() ? bna.dir.externDependModules : bna.externDependModules;
        return f(mpath, function(err, dependencies) {
          var targetPath;
          targetPath = path.join(dependencies[0].mpath, "node_modules");
          if (!fs.existsSync(targetPath)) {
            wrench.mkdirSyncRecursive(targetPath);
          }
          return async.eachSeries(dependencies.slice(1), function(d, cb) {
            var targetModulePath;
            targetModulePath = path.join(targetPath, path.basename(d.mpath));
            progressCb(_("Copying '%s': %s => %s").format(d.require, path.relative(process.cwd(), d.mpath), path.relative(process.cwd(), targetModulePath)));
            if (!fs.existsSync(targetModulePath)) {
              fs.mkdirSync(targetModulePath);
            }
            return wrench.copyDirRecursive(d.mpath, targetModulePath, cb);
          }, doneCb);
        });
      });
    },

    /*
     * Merge the module dependency calculated by bna.npmDependencies or bna.dir.npmDependencies into the package.json
     * of main module. The merge rules are:
     * 1. if not exist yet, dependency is added
     * 2. otherwise, do not modify current package.json
          a. however if detected dependency exits in current package.json, then check if versions are compatible,
     *
     * @param mpath     path to a dir or file (the file must be main entry point of module, i.e. returned by require.resolve
     * @param cb(err, [] )  [] is removed packages
     */
    writePackageJson: function(mpath, cb) {
      var semver;
      semver = require("semver");
      return fs.stat(mpath, function(err, stat) {
        var f;
        if (err) {
          return cb(err);
        }
        f = stat.isDirectory() ? bna.dir.npmDependencies : bna.npmDependencies;
        return f(mpath, function(err, deps) {
          var errList, newdep, oldDep, pkgJson, pkgJsonFile;
          if (err) {
            return cb(err);
          }
          if (stat.isFile()) {
            mpath = bna.identify(mpath).mpath;
          }
          pkgJsonFile = path.join(mpath, "package.json");
          pkgJson = {};
          if (fs.existsSync(pkgJsonFile)) {
            pkgJson = JSON.parse(fs.readFileSync(pkgJsonFile, "utf8"));
          }
          oldDep = pkgJson.dependencies || {};
          newdep = {};
          errList = [];
          _(deps).each(function(version, name) {
            var oldVer;
            if (version === null) {
              return errList.push(_("%s is not versioned!").format(name));
            } else if (!(name in oldDep)) {
              return newdep[name] = version;
            } else {
              oldVer = oldDep[name];
              if (/:\/\//.test(oldVer)) {
                console.log(_("Package %s is ignored due to non-semver %s").format(name, oldVer));
                delete oldDep[name];
                return newdep[name] = oldVer;
              } else if (!semver.satisfies(version, oldVer)) {
                return errList.push(_("%s: actual version %s does not satisfy package.json's version %s").format(name, version, oldVer));
              } else {
                delete oldDep[name];
                return newdep[name] = oldVer;
              }
            }
          });
          if (errList.length > 0) {
            return cb(new Error(errList.join("\n")));
          } else {
            pkgJson.dependencies = newdep;
            return fs.writeFile(pkgJsonFile, JSON.stringify(pkgJson, null, 2), "utf8", function(err) {
              return cb(err, _(oldDep).keys());
            });
          }
        });
      });
    },

    /*
      Given js sourcecode, find require, returns
      { strings: [ ['name', location], ...]
        expressions : [['expr', location], ...]
      }
      * location is only set if opt.loc is true
      opt: { loc : true/false }
     */
    findRequire: function(filepath, opt) {
      var e, modules, src, src_ast;
      if (opt == null) {
        opt = {};
      }
      src = fs.readFileSync(filepath).toString();
      if (typeof src !== 'string') {
        src = String(src);
      }
      src = src.replace(/^#![^\n]*\n/, '');
      modules = {
        strings: [],
        expressions: []
      };
      if (src.indexOf('require') === -1 || /\.json$/i.test(filepath) || /\.node$/i.test(filepath)) {
        return modules;
      }
      try {
        src_ast = esprima.parse(src, opt);
      } catch (_error) {
        e = _error;
        console.log("Ignoring " + filepath + ", esprima failed to parse due to: " + e);
        return modules;
      }
      ast.traverse(src_ast, function(node) {
        if (ast.isRequire(node)) {
          if (opt.loc) {
            node.loc.file = filepath;
            if (node["arguments"].length && node["arguments"][0].type === 'Literal') {
              return modules.strings.push([node["arguments"][0].value, node.loc]);
            } else {
              return modules.expressions.push([node["arguments"][0], node.loc]);
            }
          } else {
            if (node["arguments"].length && node["arguments"][0].type === 'Literal') {
              return modules.strings.push([node["arguments"][0].value]);
            } else {
              return modules.expressions.push([node["arguments"][0]]);
            }
          }
        }
      });
      return modules;
    },
    fuse: function(filepath, outdir, moduleName, opts) {
      var getreqs, ret, unit, units, warnings;
      if (opts == null) {
        opts = {};
      }
      filepath = path.resolve(filepath);
      unit = bna._parseFile(filepath, {}, opts.fakeCode);
      getreqs = function(unit, cache) {
        var child_unit, node, units;
        if (unit.fpath in cache) {
          return cache[unit.fpath];
        }
        cache[unit.fpath] = units = [];
        _(units).append(_((function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = unit.requires;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], node = _ref1.node, child_unit = _ref1.unit;
            _results.push(getreqs(child_unit, cache));
          }
          return _results;
        })()).flatten());
        units.push(unit);
        return units;
      };
      units = getreqs(unit, {});
      units = _(units).unique(function(unit) {
        return unit.fpath;
      });
      warnings = _((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = units.length; _i < _len; _i++) {
          unit = units[_i];
          _results.push(unit.warnings);
        }
        return _results;
      })()).flatten();
      ret = (require("./fuse")).generate({
        baseDir: outdir,
        moduleName: moduleName,
        units: units,
        asLib: opts.aslib,
        verbose: !bna.quiet
      });
      ret.push.apply(ret, [warnings, units]);
      return ret;
    },
    generateModuleName: function(fullpath) {
      var ret;
      ret = path.basename(fullpath).replace(/\..*$/, '');
      if (ret.toLowerCase() === "index") {
        ret = path.basename(path.dirname(fullpath));
      }
      return ret;
    },
    prettyWarnings: function(warnings) {
      var dynamicModules, error, m, msgs, node, pe, pl, reason, _i, _len, _ref, _results;
      msgs = {
        'nonconst': 'require dynamic modules: ',
        'resolve': 'require ignored because parameter can not be resolved',
        'dynamicResolveError': 'dynamic required module resolve error'
      };
      pl = function(l) {
        if (l) {
          return l;
        } else {
          return '';
        }
      };
      pe = function(e) {
        if (e) {
          return ', ' + e;
        } else {
          return '';
        }
      };
      m = function(dynamicModules) {
        if (dynamicModules) {
          return JSON.stringify(dynamicModules);
        } else {
          return '';
        }
      };
      _results = [];
      for (_i = 0, _len = warnings.length; _i < _len; _i++) {
        _ref = warnings[_i], node = _ref.node, reason = _ref.reason, error = _ref.error, dynamicModules = _ref.dynamicModules;
        _results.push("" + (path.relative('.', node.loc.fpath)) + ":" + (pl(node.loc.start.line)) + ": " + msgs[reason] + (pe(error)) + " " + (m(dynamicModules)));
      }
      return _results;
    },
    fuseTo: function(filepath, dstdir, opts) {
      var binaryunits, bunit, content, dfile, dstfile, moduleName, smFile, sourcemap, units, warning, warnings, _i, _j, _len, _len1, _ref, _ref1;
      if (opts == null) {
        opts = {};
      }
      filepath = path.resolve(filepath);
      moduleName = bna.generateModuleName(opts.dstfile || filepath);
      _ref = bna.fuse(filepath, dstdir, moduleName, opts), content = _ref[0], binaryunits = _ref[1], sourcemap = _ref[2], warnings = _ref[3], units = _ref[4];
      _ref1 = bna.prettyWarnings(warnings);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        warning = _ref1[_i];
        bna.warn(warning);
      }
      wrench.mkdirSyncRecursive(dstdir);
      dstfile = path.resolve(dstdir, opts.dstfile || (path.basename(filepath, ".js") + ".fused.js"));
      smFile = dstfile + ".map";
      console.log("Generating " + (path.relative('.', dstfile)));
      fs.writeFileSync(dstfile, content);
      if (sourcemap) {
        console.log("Generating " + (path.relative('.', smFile)));
        sourcemap.file = path.basename(dstfile);
        fs.writeFileSync(smFile, JSON.stringify(sourcemap, null, 2));
        fs.appendFileSync(dstfile, "\n//# sourceMappingURL=" + (path.basename(smFile)));
      }
      for (_j = 0, _len1 = binaryunits.length; _j < _len1; _j++) {
        bunit = binaryunits[_j];
        dfile = path.resolve(dstdir, bunit.binName);
        if (fs.existsSync(dfile)) {
          bna.warn("Skipped copying " + dfile + ", already exists.");
        } else {
          bna.warn("Copying to " + dfile);
          wrench.mkdirSyncRecursive(path.dirname(dfile));
          fs.createReadStream(bunit.fpath).pipe(fs.createWriteStream(dfile));
        }
      }
      return units;
    },
    fuseDirTo: function(dirpath, dstdir, opts, cb) {
      var fakeCode, scandir;
      fakeCode = "";
      scandir = function(curdir, cb) {
        var files, fnpm;
        files = [];
        fnpm = require("fstream-npm");
        return fnpm({
          path: curdir
        }).on("child", function(c) {
          return files.push(c._path);
        }).on('close', function() {
          var extname, fpath, mpath, name, pkg, recursePaths, stat, _i, _len;
          recursePaths = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            name = files[_i];
            fpath = path.resolve(curdir, name);
            stat = fs.statSync(fpath);
            if (stat.isFile()) {
              extname = path.extname(name).toLowerCase();
              if (name.toLowerCase() === "package.json") {
                pkg = JSON.parse(fs.readFileSync(fpath));
                if (pkg.main) {
                  mpath = path.resolve(path.dirname(fpath), pkg.main);
                  fakeCode += "require('./" + (path.relative(dirpath, mpath)) + "')\n";
                }
              } else if (extname === ".js" || extname === ".node") {
                fakeCode += "require('./" + (path.relative(dirpath, fpath)) + "')\n";
              }
            } else if (stat.isDirectory()) {
              if (fs.existsSync(path.resolve(fpath, "package.json")) || fs.existsSync(path.resolve(fpath, "index.js")) || fs.existsSync(path.resolve(fpath, "index.node"))) {
                fakeCode += "require('./" + (path.relative(dirpath, fpath)) + "')\n";
              } else {
                recursePaths.push(fpath);
              }
            }
          }
          return async.eachSeries(recursePaths, function(path, cb) {
            return scandir(fpath, cb);
          }, cb);
        });
      };
      return scandir(dirpath, function() {
        var units;
        if (!fakeCode) {
          console.log("No files detected");
        } else {
          opts.fakeCode = fakeCode;
          units = bna.fuseTo(path.resolve(dirpath, "lib.js"), dstdir, opts);
        }
        if (cb) {
          return cb(units);
        }
      });
    },
    fileDep: function(filepath) {
      var getreqs, ret, u, unit, units, warnings, _i, _len;
      filepath = path.resolve(filepath);
      unit = bna._parseFile(filepath, {});
      getreqs = function(unit, cache) {
        var child_unit, node, units;
        if (unit.fpath in cache) {
          return cache[unit.fpath];
        }
        cache[unit.fpath] = units = [];
        _(units).append(_((function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = unit.requires;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], node = _ref1.node, child_unit = _ref1.unit;
            _results.push(getreqs(child_unit, cache));
          }
          return _results;
        })()).flatten());
        units.push(unit);
        return units;
      };
      units = getreqs(unit, {});
      units = _(units).unique(function(unit) {
        return unit.fpath;
      });
      warnings = _((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = units.length; _i < _len; _i++) {
          unit = units[_i];
          _results.push(unit.warnings);
        }
        return _results;
      })()).flatten();
      ret = {};
      for (_i = 0, _len = units.length; _i < _len; _i++) {
        u = units[_i];
        if (u["package"]) {
          ret[u["package"].name] = u["package"].version;
        }
      }
      return [ret, warnings];
    },
    _parseFile: function(filepath, cache, overrideContent) {
      var bad_require_detected, code, dynamicModules, dynamic_require_detected, e, isBinary, isCore, unit;
      if (filepath in cache) {
        return cache[filepath];
      }
      isCore = !/[\\\/]/.test(filepath);
      isBinary = /\.node$/i.test(filepath);
      unit = {
        isCore: isCore,
        isBinary: isBinary,
        fpath: filepath,
        src: "",
        requires: [],
        warnings: [],
        "package": void 0
      };
      cache[filepath] = unit;
      if (isCore || isBinary) {
        return unit;
      }
      if (overrideContent) {
        unit.src = overrideContent;
      } else {
        unit.src = fs.readFileSync(filepath).toString().replace(/^#![^\n]*\n/, '');
      }
      if (path.extname(filepath).toLowerCase() === ".json") {
        return unit;
      }
      (function() {
        var detail, main, mainfiles, _ref;
        detail = bna.identify(filepath);
        mainfiles = [path.join(detail.mpath, "index.js"), path.join(detail.mpath, "index.node")];
        if (detail["package"]) {
          detail["package"].name = detail.require;
          if (detail["package"].main) {
            main = path.resolve(detail.mpath, detail["package"].main);
            mainfiles.push(main);
            if (path.extname(main) === '') {
              mainfiles.push.apply(mainfiles, ["" + main + ".js", "" + main + ".node"]);
            }
          }
        }
        if (_ref = unit.fpath, __indexOf.call(mainfiles, _ref) >= 0) {
          return unit["package"] = detail["package"] || {
            name: detail.require,
            version: 'x'
          };
        }
      })();
      bad_require_detected = false;
      dynamic_require_detected = false;
      try {
        code = esprima.parse(unit.src, {
          loc: false
        });
      } catch (_error) {
        e = _error;
        console.log("Ignoring " + filepath + ", esprima failed to parse due to: " + e);
        return unit;
      }
      ast.traverse(code, [ast.isRequire], function(node) {
        var arg, fullpath, modulename, runit;
        arg = node["arguments"][0];
        if (arg && arg.type === 'Literal') {
          modulename = arg.value;
          e = void 0;
          try {
            fullpath = resolver.sync(modulename, {
              extensions: ['.js', '.node', '.json'],
              basedir: path.dirname(filepath)
            });
          } catch (_error) {
            e = _error;
            bad_require_detected = true;
          }
          if (!e) {
            runit = bna._parseFile(fullpath, cache);
            return unit.requires.push({
              node: node,
              unit: runit
            });
          }
        } else {
          return dynamic_require_detected = true;
        }
      });
      dynamicModules = [];
      if (dynamic_require_detected) {
        (function(_this) {
          return (function() {
            var fullpath, modulename, node, r, runit, _i, _len, _results;
            dynamicModules = bna.detectDynamicRequires(unit);
            _results = [];
            for (_i = 0, _len = dynamicModules.length; _i < _len; _i++) {
              modulename = dynamicModules[_i];
              e = void 0;
              try {
                fullpath = resolver.sync(modulename, {
                  extensions: ['.js', '.node', '.json'],
                  basedir: path.dirname(filepath)
                });
              } catch (_error) {
                e = _error;
                unit.warnings.push({
                  node: {
                    loc: {
                      fpath: fullpath,
                      start: {
                        line: null
                      }
                    },
                    "arguments": [
                      {
                        'value': modulename
                      }
                    ]
                  },
                  reason: "resolve"
                });
              }
              if (!e) {
                if (((function() {
                  var _j, _len1, _ref, _results1;
                  _ref = unit.requires;
                  _results1 = [];
                  for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                    r = _ref[_j];
                    if (r.unit.fpath === fullpath) {
                      _results1.push(r);
                    }
                  }
                  return _results1;
                })()).length === 0) {
                  node = {
                    loc: {
                      fpath: fullpath,
                      start: {
                        line: null
                      }
                    },
                    "arguments": [
                      {
                        'value': modulename
                      }
                    ]
                  };
                  runit = bna._parseFile(fullpath, cache);
                  _results.push(unit.requires.push({
                    node: node,
                    unit: runit
                  }));
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
        })(this)();
      }
      if (bad_require_detected || dynamic_require_detected) {
        code = esprima.parse(unit.src, {
          loc: true
        });
        ast.traverse(code, [ast.isRequire], function(node) {
          var arg, modulename;
          node.loc.fpath = filepath;
          arg = node["arguments"][0];
          if (arg && arg.type === 'Literal') {
            modulename = arg.value;
            try {
              return resolver.sync(modulename, {
                extensions: ['.js', '.node', ".json"],
                basedir: path.dirname(filepath)
              });
            } catch (_error) {
              e = _error;
              return unit.warnings.push({
                node: node,
                reason: "resolve"
              });
            }
          } else {
            return unit.warnings.push({
              node: node,
              reason: "nonconst",
              dynamicModules: dynamicModules
            });
          }
        });
      }
      return unit;
    },
    detectDynamicRequires: function(unit) {
      var dmodules, e, ret, src;
      dmodules = [];
      src = "(function() {\nvar exports = {}\nvar module = { \"exports\": exports }\nvar __filename = \"" + unit.fpath + "\"\nvar __dirname = \"" + (path.dirname(unit.fpath)) + "\"\nvar require = function(module) {\n  dmodules.push(module)\n  return function(){}   // require(\"blah\").x.x  will still fail, but what can u do?!\n};\n" + unit.src + "\n})()";
      try {
        eval(src);
      } catch (_error) {
        e = _error;
        unit.warnings.push({
          node: {
            loc: {
              fpath: unit.fpath,
              start: {
                line: null
              }
            },
            "arguments": [
              {
                'value': ''
              }
            ]
          },
          reason: 'dynamicResolveError',
          error: e
        });
      }
      ret = _.unique(dmodules);
      return ret;
    }
  };

}).call(this);

//# sourceMappingURL=bna.js.map
